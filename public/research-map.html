<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="icon" href="../../favicon.ico">
    <link type="text/css" rel="stylesheet" href="css/materialize.min.css"  media="screen,projection"/>
    <link href="http://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="font-awesome-4.6.3/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//rawgithub.com/Caged/d3-tip/master/examples/example-styles.css">
    <link rel="stylesheet" href="css/main.css">

    <title>Graf wspolpracy</title>
</head>

<body>

<script src="https://d3js.org/d3-path.v1.min.js"></script>
<script src="js/jquery-3.1.0.min.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="js/remove-diacritics.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="js/d3-tip.js"></script>
<script src="js/parse-raw-expertus.js"></script>
<script src="js/collab-demo-1.js"></script>
<script src="js/bar-graph.js"></script>
<script src="js/works-over-time-demo-1.js"></script>
<script src="js/expertus-retriever.js"></script>
<script src="js/collab.js"></script>


<nav>
    <div class="nav-wrapper">
        <a href="#" class="brand-logo">Wizualizator naukowca</a>
        <ul id="nav-mobile" class="right hide-on-med-and-down">
            <li><a href="index.html">Wizualizacje</a></li>
        </ul>
    </div>
</nav>
<div class="row">
    <div class="col s4" style="padding-left: 0">
        <div class="z-depth-1 vis-info">
            <div class ="row">
                <div class="card">
                    <div class="card-content white-text">
                        <span class="card-title">Koło dziedzin</span>
                        <p>Koło rozmieszczające publikacje w przestrzeni dziedzin na podstawie czasopisma, w którym została opublikowana.</p>
                    </div>
                </div>
            </div>

        </div>

    </div>
    <div class="col s8">
        <svg class="z-depth-1 svg-port" id="svg-port"></svg>
    </div>
</div>




<script>

    $(document).ready(function () {
        DrawDomains();
    });

//    function drawMap(data) {
//        var svg = d3.select('#svg-port');
//
//
//

//                .call(d3.drag()
//                        .on("start", dragstarted)
//                        .on("drag", dragged)
//                        .on("end", dragended))
//                .on('mouseover', nodeTip.show)
//                .on('mouseout', nodeTip.hide);
//
//        simulation
//                .nodes(data.simNodes)
//                .on("tick", ticked);
//
//        simulation.force("link")
//                .links(data.simLinks);
//
//        function ticked() {
//            link
//                    .attr("x1", function (d) {
//                        return d.source.x;
//                    })
//                    .attr("y1", function (d) {
//                        return d.source.y;
//                    })
//                    .attr("x2", function (d) {
//                        return d.target.x;
//                    })
//                    .attr("y2", function (d) {
//                        return d.target.y;
//                    });
//
//            node
//                    .attr("cx", function (d) {
//                        return d.x;
//                    })
//                    .attr("cy", function (d) {
//                        return d.y;
//                    });
//        }
//
//        function dragstarted(d) {
//            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
//            d.fx = d.x;
//            d.fy = d.y;
//        }
//
//        function dragged(d) {
//            d.fx = d3.event.x;
//            d.fy = d3.event.y;
//        }
//
//        function dragended(d) {
//            if (!d3.event.active) simulation.alphaTarget(0);
//            d.fx = null;
//            d.fy = null;
//        }
//    }

    /**
     * @param domainsList {Array}  Weighted list of domains ex: [{topic: phys, weight: 1}, {topic: bio, weight:4}]
     */
    function DivideDomains(domainsList) {
        var sumOfWeights = 0;
        domainsList.forEach(function (el) {
            sumOfWeights += el.weight;
        });
        console.log('sum of weights ' + sumOfWeights);
        var angleCounter = 0;
        return domainsList.map(function (weightedDomain) {
            var current = {
                begin: angleCounter,
                end: angleCounter + ( weightedDomain.weight / sumOfWeights ) * 2 * Math.PI
            };
            angleCounter += ( ( weightedDomain.weight / sumOfWeights ) * 2 * Math.PI );
            return {
                angleBounds: current,
                topic: weightedDomain.topic,
                hue: weightedDomain.hue

            };
        })
    }

    /**
     * @param radius {Number} Radius for cartesian conversion
     * @param anglePositions {Array} [ [domain starting angle, domain ending angle], ...]
     */
    function GetCartesianDomainCentres(anglePositions, radius) {
        var centres = anglePositions.map(function (pos) {
            return {
                centre: pos.angleBounds.begin + ((pos.angleBounds.end - pos.angleBounds.begin) / 2) - toRad(90),
                topic: pos.topic
            };
        });
        var DomainToCentreCoordinatesMap = {};
        centres.forEach(function (centre) {
            DomainToCentreCoordinatesMap[centre.topic] = PolarToCartesian(centre.centre, radius * 3 / 4);
        });
        return DomainToCentreCoordinatesMap;
    }

    function DrawDomains() {
        var svg = d3.select("#svg-port"),
                jQPort = $(".svg-port"),
                width = jQPort.width(),
                height = jQPort.height();
        var radius = height / 3;
        var ringWidth = 40;
        var centre =
        {
            x: width / 2,
            y: height / 2
        };
        var padAngle = toRad(5);


        var exampleDomains = [
            {
                topic: "Nauki fizyczne",
                weight: 1,
                hue: "#8A38C0"
            },
            {
                topic: "Nauki o życiu",
                weight: 1,
                hue: "#E45035"
            },
            {
                topic: "Badania kliniczne",
                weight: 1,
                hue: "#D7747E"
            },
            {
                topic: "Nauki społeczne",
                weight: 1,
                hue: "#D4AF92"
            },
            {
                topic: "Nauki humanistyczne",
                weight: 1,
                hue: "#7E7E7E"
            },
            {
                topic: "Nauki inżynieryjne",
                weight: 1,
                hue: "#21D4F1"
            }
        ];

        var Publications = [
            {
                topics:
                [{
                    topic:"Nauki humanistyczne",
                    weight: 1
                }],
                title: "Publication 1",
                anchor: false
            },
            {
                topics:
                [
                    {
                        topic:"Nauki o życiu",
                        weight: 0.5
                    },
                    {
                        topic: "Badania kliniczne",
                        weight: 0.5
                    }
                ],
                title: "Publication 2",
                anchor: false
            },
            {
                topics:
                        [
                            {
                                topic:"Nauki fizyczne",
                                weight: 0.8
                            },
                            {
                                topic: "Nauki społeczne",
                                weight: 0.2
                            }
                        ],
                title: "Publication 4",
                anchor: false
            },
            {
                topics:
                        [
                            {
                                topic:"Badania kliniczne",
                                weight: 0.8
                            },
                            {
                                topic: "Nauki fizyczne",
                                weight: 0.2
                            }
                        ],
                title: "Publication 5",
                anchor: false
            },
            {
                topics:
                        [
                            {
                                topic:"Badania kliniczne",
                                weight: 0.5
                            },
                            {
                                topic: "Nauki humanistyczne",
                                weight: 0.5
                            }
                        ],
                title: "Publication 3",
                anchor: false
            }
        ];

        var angleBounds = DivideDomains(exampleDomains);
        console.log('angle bounds');
        console.log(angleBounds);
        var domainCoordinates = GetCartesianDomainCentres(angleBounds, radius);

        console.log('Domain coordinates');
        console.log(domainCoordinates);
        angleBounds.forEach(function(domain){
            Publications.push({
                anchor: true,
                fx: domainCoordinates[domain.topic].x,
                fy: domainCoordinates[domain.topic].y,
                title: domain.topic
            })
        });

        var linksToDomains = [];
        Publications.forEach(function (publication) {
            if(!publication.anchor) publication.topics.forEach(function (topic) {
                linksToDomains.push({
                    source: publication.title,
                    target: topic.topic,
                    weight: topic.weight
                        })
            })
        })
        console.log('Domain links:');
        console.log(linksToDomains);

        var domainArcs = d3
                .arc()
                .innerRadius(radius - ringWidth)
                .outerRadius(radius)
                .startAngle(function (d) {
                    return d.angleBounds.begin + padAngle/2;
                })
                .endAngle(function (d) {
                    return d.angleBounds.end - padAngle/2;
                });

        console.log(angleBounds);
        var arcsGroup = svg
                .append('g')
                .attr('id', 'arcs-g');

        angleBounds.forEach(function (angles) {
            arcsGroup.append('path')
                    .attr('d', domainArcs(angles))
                    .attr('id', angles.topic)
                    .attr('transform', 'translate(' + centre.x + ' , ' + centre.y + ')')
                    .attr('fill', function () {
                        return angles.hue
                    });

            svg.append("text")
                    .append("textPath")
                    .attr("xlink:href", '#' + angles.topic)
                    .style("text-anchor","middle")
                    .attr("startOffset", "23%")
                    .text(angles.topic);
        });




        var simulation = d3.forceSimulation()
                .force("link", d3.forceLink()
                        .id(function (d) {
                            return d.title
                        })
                        .distance(function (d) {
                            return (radius / 8) / d.weight
                        })
                        .strength(function (d) {
                            return d.weight
                        }))
                .alphaDecay(0.015)
                .velocityDecay(0.1)
//                .force("center",
//                        d3.forceCenter(centre.x, centre.y));

        simulation
                .nodes(Publications)
                .on('tick', updateOnTick);


        simulation.force("link")
                .links(linksToDomains);

        var nodeTip = d3.tip().attr('class', 'd3-tip').html(function(d) {
            var string = '';
            d.topics.forEach(function (topic, index) {
                if(index != 0) string += '<br>';
                string += topic.topic + ' : ' + topic.weight;
            });
            return string;
        });
        svg.call(nodeTip);

        var node = svg.append("g")
                .attr("class", "nodes")
                .selectAll("circle")
                .data(Publications)
                .enter().append("circle")
                .attr("r", function (d) {
                    return 5
                })
                .attr("fill", "#898989")
                .attr("stroke", "#434343")
                .attr("stroke-width", "1px")
                .attr('cx', function (d) {
                    return d.x
                })
                .attr('cy', function (d) {
                    return d.y
                })
                .style('visibility', function (d) {
                    if(d.anchor) return 'hidden';
                    return 'visible';
                })
                .attr('transform', 'translate(' + centre.x + ' , ' + centre.y + ')')
                .call(d3.drag()
                        .on("start", dragstarted)
                        .on("drag", dragged)
                        .on("end", dragended))
                .on('mouseover', nodeTip.show)
                .on('mouseout', nodeTip.hide)

        function dragstarted(d) {
            if(d.anchor) return;
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(d) {
            if(d.anchor) return;
            d.fx = d3.event.x;
            d.fy = d3.event.y;
        }

        function dragended(d) {
            if(d.anchor) return;
            if (!d3.event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        function updateOnTick() {
            node
                    .attr("cx", function (d) {
                        return d.x;
                    })
                    .attr("cy", function (d) {
                        return d.y;
                    });
        }


//        var link = svg.append("g")
//                .attr("class", "links")
//                .selectAll("line")
//                .data(data.simLinks)
//                .enter().append("line")
//                .attr("stroke-width", function (d) {
//                    return Math.sqrt(d.value);
//                })
//                .style("stroke", d3.rgb(69,67,67))
//                .style("stroke-opacity", 0.5);



    }

//    /**
//     * @param radius {Number} Radius for cartesian conversion
//     * @param anglePositions {Array} [ [domain starting angle, domain ending angle], ...]
//     */
//    function GetCartesianDomainBounds(anglePositions, radius) {
//        return anglePositions
//    }



    var colorCounter = 0;
    function NextColor() {
        if (colorCounter >= 9) colorCounter = 0;
        return d3.schemeSet2[colorCounter++];
    }

    function displayWorkStatsCollab (data) {

        var displayValues = {
            coworkersAmount: data.simNodes.length - 1,
            mostSharedWorks: 1,
            sumOfWorks: 0
        };

        data.simNodes.forEach(function (coauthor, index) {
            if(coauthor.strengthValue > displayValues.mostSharedWorks && index != 0) {
                displayValues.mostSharedWorks = coauthor.strengthValue;
                displayValues.mostSharedWorksWith = coauthor.id;
            }
            displayValues.sumOfWorks += coauthor.strengthValue
        });
        displayValues.meanAmountOfWorks = displayValues.sumOfWorks / data.simNodes.length;

        console.log(displayValues);

        $('#coworkers-amount-display').text(displayValues.coworkersAmount);
        $('#max-shared-works-amount-display').text(displayValues.mostSharedWorksWith + ' (' + displayValues.mostSharedWorks + ') ');
        $('#mean-coworkers-amount-display').text(displayValues.meanAmountOfWorks.toFixed(2));
        $('#works-amount-display').text(displayValues.sumOfWorks)
    }

    function ConvertDbOutputIntoLegacyExpertusFormat(data, mainName) { //[ {authors: [author1, author2]} ]
        var LegacyCollaboratorList = [];

        data.forEach(function (work) {
            var singleWorkAuthors = [];
            work.authors.forEach(function (author) {
                if(author != mainName) singleWorkAuthors.push(author);
            });
            LegacyCollaboratorList.push(singleWorkAuthors)
        });

        return LegacyCollaboratorList
    }



    if (!Array.prototype.includes) {
        Array.prototype.includes = function(searchElement /*, fromIndex*/) {
            'use strict';
            if (this == null) {
                throw new TypeError('Array.prototype.includes called on null or undefined');
            }

            var O = Object(this);
            var len = parseInt(O.length, 10) || 0;
            if (len === 0) {
                return false;
            }
            var n = parseInt(arguments[1], 10) || 0;
            var k;
            if (n >= 0) {
                k = n;
            } else {
                k = len + n;
                if (k < 0) {k = 0;}
            }
            var currentElement;
            while (k < len) {
                currentElement = O[k];
                if (searchElement === currentElement ||
                        (searchElement !== searchElement && currentElement !== currentElement)) { // NaN !== NaN
                    return true;
                }
                k++;
            }
            return false;
        };
    }


    function PolarToCartesian(angle, length) {
        return {
            x: Math.cos(angle) * length,
            y: Math.sin(angle) * length
        }
    }
    function toRad(deg) {
        return deg*Math.PI/180;
    }
    function getPositions (previousPositions, currentAmount) {
        var range = 360 / currentAmount;
        // if(range == 360) range = 180;
        var currentPositions = [];
        for(var angle = 0; angle < 360; angle += range) {
            currentPositions.push(angle);
        }

        var positionDifferences = [];
        var minimalPositionDifference = 0, currentBestOffset = 0;
        for(var offset=0; offset<range; offset += (range/20) ) {

            positionDifferences = currentPositions.map(function (position) {
                var distancesFromSinglePoint = [];
                previousPositions.forEach(function (previousPosition) {
                    distancesFromSinglePoint.push(Math.abs(previousPosition - position - offset) % 180);
                });
                //console.log(Math.min.apply(null, distancesFromSinglePoint));
                return Math.min.apply(null, distancesFromSinglePoint);
            });

            if(Math.min.apply(null, positionDifferences) > minimalPositionDifference) {
                minimalPositionDifference = Math.min.apply(null, positionDifferences);
                currentBestOffset = offset
            }

        }

        return currentPositions.map(function (position) {
            return position + currentBestOffset;
        })
    }

    function getRingValues(singleCollaborationList) {

        singleCollaborationList = singleCollaborationList.sort(compareCollaboratorsByAmount);

        var ringValues = [{
            worksAmount: 1,
            people: []
        }];
        for(var i = 1; i<singleCollaborationList.length; i++) {
            if(singleCollaborationList[i-1].amount != singleCollaborationList[i].amount) {
                ringValues.push( {
                    worksAmount: singleCollaborationList[i].amount,
                    people: [singleCollaborationList[i].name]
                } )
            }
            else {
                ringValues[ ringValues.length - 1 ].people.push(singleCollaborationList[i].name);
            }
        }
        return ringValues;
    }

    function incrementCollaboration (arr, name) {
        for(var i=0; i<arr.length; i++) {
            if(arr[i].name == name) {
                arr[i].amount++;
                return
            }
        }
    }

    function getCompleteCollaboratorList ( allWorks ) {

        var allCollaborators = [];
        var allCollaboratorsWithAmounts = [];
        var collaborationAmountArray = [];
        allWorks.forEach(function (work) {
            work.forEach(function (person) {
                if(!allCollaborators.includes(person)) {
                    allCollaborators.push(person);
                    collaborationAmountArray.push(
                            {
                                name: person,
                                amount: 0
                            })
                }

            })
        });

        allCollaborators.forEach(function (person) {
            allCollaboratorsWithAmounts.push(
                    {
                        name: person,
                        collaborations: JSON.parse(JSON.stringify(collaborationAmountArray))
                    })
        });


        allCollaboratorsWithAmounts.forEach(function (collaborator, index, arr) {
            for(var i=0; i<allWorks.length; i++) {
                if(allWorks[i].includes(collaborator.name)) {
                    allWorks[i].forEach(function (person) {
                        incrementCollaboration(collaborator.collaborations, person);
                    });
                }
            }
        });

        return allCollaboratorsWithAmounts;
    }

    function compareCollaboratorsByAmount (a, b) {
        if (a.amount < b.amount) {
            return -1;
        }
        if (a.amount > b.amount) {
            return 1;
        }
        return 0;
    }

    function clearSvg() {
        d3.select('svg').selectAll('*').remove();
    }

    function ParseExpertusCollaborationList(rawText) { //an array of arrays containing author names
        rawText = rawText.trim();
        var lines = rawText.split('\n');
        var works = [];
        for(var i=0; i<lines.length; i++) {
            var people = [];
            while(isPerson(lines[i]) != false && i < lines.length) {
                people.push(isPerson(lines[i]));
                i++
            }
            if(people.length > 0) works.push(people);
        }

        return(works);
    }

    function PolskaFleksjaSlowaPraca(word, number) {
        if(number == 1) return number + ' praca'
        if(number >=2 && number <=4) return number + ' prace'
        return number + ' prac'
    }

</script>


</body>
</html>